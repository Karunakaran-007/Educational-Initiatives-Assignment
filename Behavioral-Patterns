OBSERVER PATTERN
import java.util.ArrayList;
import java.util.List;

// Observer Interface
interface Observer {
    void update(String stockName, double price);
}

// Concrete Observer
class StockViewer implements Observer {
    private String name;

    public StockViewer(String name) {
        this.name = name;
    }

    @Override
    public void update(String stockName, double price) {
        System.out.println(name + " is viewing the updated price of " + stockName + ": $" + price);
    }
}

// Subject Interface
interface StockSubject {
    void registerObserver(Observer observer);
    void removeObserver(Observer observer);
    void notifyObservers();
}

// Concrete Subject
class Stock implements StockSubject {
    private String stockName;
    private double price;
    private List<Observer> observers = new ArrayList<>();

    public Stock(String stockName, double price) {
        this.stockName = stockName;
        this.price = price;
    }

    public void setPrice(double price) {
        this.price = price;
        notifyObservers();
    }

    @Override
    public void registerObserver(Observer observer) {
        observers.add(observer);
    }

    @Override
    public void removeObserver(Observer observer) {
        observers.remove(observer);
    }

    @Override
    public void notifyObservers() {
        for (Observer observer : observers) {
            observer.update(stockName, price);
        }
    }
}

public class ObserverPatternDemo {
    public static void main(String[] args) {
        Stock appleStock = new Stock("Apple", 145.00);
        
        StockViewer viewer1 = new StockViewer("Viewer 1");
        StockViewer viewer2 = new StockViewer("Viewer 2");
        
        appleStock.registerObserver(viewer1);
        appleStock.registerObserver(viewer2);
        
        appleStock.setPrice(150.00); // All observers will be notified
    }
}

Strategy Pattern
// Strategy interface
interface SortStrategy {
    void sort(int[] array);
}

// Concrete Strategy 1: QuickSort
class QuickSort implements SortStrategy {
    @Override
    public void sort(int[] array) {
        System.out.println("Sorting array using QuickSort.");
        // Implement QuickSort algorithm here
    }
}

// Concrete Strategy 2: MergeSort
class MergeSort implements SortStrategy {
    @Override
    public void sort(int[] array) {
        System.out.println("Sorting array using MergeSort.");
        // Implement MergeSort algorithm here
    }
}

// Context class
class SortingContext {
    private SortStrategy sortStrategy;

    public void setSortStrategy(SortStrategy sortStrategy) {
        this.sortStrategy = sortStrategy;
    }

    public void executeSort(int[] array) {
        sortStrategy.sort(array);
    }
}

public class StrategyPatternDemo {
    public static void main(String[] args) {
        SortingContext context = new SortingContext();

        int[] array = {5, 2, 9, 1, 5, 6};

        context.setSortStrategy(new QuickSort());
        context.executeSort(array);

        context.setSortStrategy(new MergeSort());
        context.executeSort(array);
    }
}


State Pattern
// State Interface
interface GameState {
    void play();
}

// Concrete State: Paused
class PausedState implements GameState {
    @Override
    public void play() {
        System.out.println("Game is paused.");
    }
}

// Concrete State: Playing
class PlayingState implements GameState {
    @Override
    public void play() {
        System.out.println("Game is now playing.");
    }
}

// Context class
class Game {
    private GameState currentState;

    public void setGameState(GameState state) {
        this.currentState = state;
    }

    public void play() {
        currentState.play();
    }
}

public class StatePatternDemo {
    public static void main(String[] args) {
        Game game = new Game();

        game.setGameState(new PausedState());
        game.play();

        game.setGameState(new PlayingState());
        game.play();
    }
}
Command Pattern
// Command Interface
interface Command {
    void execute();
}

// Concrete Command: TurnOnCommand
class TurnOnCommand implements Command {
    private Light light;

    public TurnOnCommand(Light light) {
        this.light = light;
    }

    @Override
    public void execute() {
        light.turnOn();
    }
}

// Concrete Command: TurnOffCommand
class TurnOffCommand implements Command {
    private Light light;

    public TurnOffCommand(Light light) {
        this.light = light;
    }

    @Override
    public void execute() {
        light.turnOff();
    }
}

// Receiver class
class Light {
    public void turnOn() {
        System.out.println("The light is ON.");
    }

    public void turnOff() {
        System.out.println("The light is OFF.");
    }
}

// Invoker class
class RemoteControl {
    private Command command;

    public void setCommand(Command command) {
        this.command = command;
    }

    public void pressButton() {
        command.execute();
    }
}

public class CommandPatternDemo {
    public static void main(String[] args) {
        Light livingRoomLight = new Light();
        
        Command turnOn = new TurnOnCommand(livingRoomLight);
        Command turnOff = new TurnOffCommand(livingRoomLight);
        
        RemoteControl remote = new RemoteControl();
        
        remote.setCommand(turnOn);
        remote.pressButton();
        
        remote.setCommand(turnOff);
        remote.pressButton();
    }
}
Iterator Pattern
// Iterator Interface
interface Iterator {
    boolean hasNext();
    Object next();
}

// Concrete Iterator
class NameIterator implements Iterator {
    private String[] names;
    private int position;

    public NameIterator(String[] names) {
        this.names = names;
        position = 0;
    }

    @Override
    public boolean hasNext() {
        return position < names.length;
    }

    @Override
    public Object next() {
        if (hasNext()) {
            return names[position++];
        }
        return null;
    }
}

// Aggregate Interface
interface NameRepository {
    Iterator createIterator();
}

// Concrete Aggregate
class NameRepositoryImpl implements NameRepository {
    private String[] names = {"Alice", "Bob", "Charlie"};

    @Override
    public Iterator createIterator() {
        return new NameIterator(names);
    }
}

public class IteratorPatternDemo {
    public static void main(String[] args) {
        NameRepository repository = new NameRepositoryImpl();
        Iterator iterator = repository.createIterator();

        while (iterator.hasNext()) {
            System.out.println("Name: " + iterator.next());
        }
    }
}


